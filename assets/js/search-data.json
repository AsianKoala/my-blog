{
  
    
        "post0": {
            "title": "FTC Kotlin Tips & Tricks",
            "content": "Neil Mehra . August 19, 2021 . . Kotlin is a statically typed, modern, concise JVM language that is designed to be fully interoperable with Java. In FTC, the most popular motion planning library, &lt;a href=https://learnroadrunner.com/&gt;Road Runner,&lt;/a&gt; is written in Kotlin. . Enabling Kotlin . First, we have to enable the Kotlin plugin in our root level gradle files. Navigate to ./build.gradle and add this line to your buildscript . ext.kotlin_version = &#39;1.5.21&#39; . Note: - at the time of writing 1.5.21 is the latest Kotlin release. . This creates an environment variable with name ‘kotlin_version’ and value ‘1.5.21’ so we don’t have to re-type the release version. . Next, add the Kotlin plugin to the dependencies block with this line . classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; . If you haven’t already, make sure the language level of the Java source code and version of the generated Java bytecode are 1.8 (JDK 8). Open up build.common.gradle and check if your compileOptions block looks like this . compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } . Once that’s finished, all that’s left to do is to enable the kotlin-android and the kotlin-stdlib-jdk8 plugins. Head over to the build.gradle of any modules you want to use Kotlin in. . Personally, I have Kotlin enabled in both the TeamCode and FTCRobotController modules as I converted the Java sample code that the FTC SDK provides to Kotlin to introduce my jr programmer to the SDK and Kotlin at the same time. Add the following definition to the top of your build.gradle file. . apply plugin: &#39;kotlin-android&#39; . Then add this line to your dependencies block. . implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version&quot; . Sync your gradle changes and then you’re all good. . . Converting your codebase to Kotlin . If you’re apprehensive about the how long it’ll take to rewrite everything, don’t worry. As Kotlin was designed to be fully functional with Java, Java source code can actually be converted directly into readable Kotlin code. Head over to Android Studio and press ctrl+alt+shift+K while a Java file is open to convert it to Kotlin. . Now that you have Kotlin files to work with, let me give some tips so that I wish I knew back when I started developing in Kotlin. . Tips &amp; Tricks . Data Classes Whenever you have classes that are only for holding data, such as a Vector or Point class, turn them into a data class. Data classes contain automatically generated functions that are derived from the constructor fields, which makes life simpler. You can also do cool things with data classes like this: val (x, y) = Point(1.0, 2.0) . | Custom getters/setters I remember during one of my first days after switching to Kotlin, I spent an entire meeting trying to debug a StackOverflowError that made no sense at all. It was erroring at a ‘simple’ variable that should never have errored, right? Or so I thought. The error was pointing to this simple line: val dbNormalize = Point(-y, x) At first glance it looks like a completely valid piece of code, but the field was actually declared in the Point data class. The Java equivalent of this would be perfectly valid, but for this you need to specify a custom getter like this: val dbNormalize get() = Point(-y, x) The full form of any Kotlin field is as follows: val foo:type = type(a, b, c...) get() = field set(value) { field = value } . | Extension Functions Extension functions were the thing that really made me feel good about switching to Kotlin. The amount of flexibility it offers is amazing. They provide you to define custom functions for any class but “extending” it. This also applies to fields/properties. For example, look at the following example. In FTC angle math is used a lot, and we always want to make sure that the angles we use are between some specified bounds, usually between -π and π. fun Double.wrap(): Double { angle = this while(angle &gt;= PI) angle -= PI * 2 while(angle &lt; -PI) angle += PI * 2 return angle } val Double.toRadians: Double = Math.toRadians(this) val Double.toDegrees: Double = Math.toDegrees(this) . Now I can call this method on any double, like this. . val myAngleDegrees = 180.0 val myAngleRad = myAngleDegrees.toRadians println(myAngleRad.wrap().toDegrees) Output: -180.0 . | Null Safety Kotlin is supposed to be safe, so what does it do with the dreaded null-types? Simple, nothing can be null unless specifically stated, and even if it is null, there are compile-time checks to make sure nothing goes haywire. To declare a variable as possibly null, you add the ? to the end of the type declaration, like this. var foo: String? = &quot;abc&quot; But what happens if it is null? At compile time if you ever access foo without checking if it’s null, Kotlin will throw a “can possibly be null” error. The correct way to access foo would be like this. val length = foo?.length ?: -1 This is equivalent to the following, more verbose expression. val l: Int = if(foo != null) foo.length else -1 And if you really do love having Null Pointer Exceptions, you can assert that a field is not null with !!. Ex: val l = b!!.length . | kotlin.math This is a short one, but the built in extension functions in the kotlin.math class feel really good to use, such as the Double.sign extension field or the Double.exp function. . | Operator Overloading Operator overloading is a must know for anyone who frequently uses any sort of data class such as the aforementioned Vector or Point data classes. Basic unary/binary operators such as the increment operator or the adding operator can be overloaded with your custom definition. Let me just show how much cleaner it is. data class Point(var x: Int, var y: Int) { operator fun plus(p: Point) = Point(x + p.x, y + p.y) operator fun times(n: Double) = Point(x * n, y * n) operator fun unaryMinus(p: Point) = this.times(-1.0) override fun toString() = x + &quot;, &quot; + y } fun main() { val foo = Point(2,3) val bar = Point(3,2) val foobar = foo + bar println(foobar.toString()) val minusfoobar = -foobar println(minusfoo.toString() } Output: 5, 5 -5, -5 . | Infix Functions Can’t talk about operator overloading without mentioning infix functions. Infix functions are functions that can be called without the dot. I’m not that much of a fan of this due to the possible danger of making stuff so simple that it gets way too overcomplicated, but it does have its uses. Sometimes when I want to approximate something equal to another, I would previously have to do this: Math.abs(a-b) &lt; 1e6 , but with infix notation it becomes a lot cleaner. infix fun Double.epsilonEquals(a: Double): Boolean { return if(this.isInfinite()) this == a else (this - a).absoluteValue &lt; EPSILON } fun main() { val foo = 1.0 val bar = foo * 1.00000000000001 println(foo epsilonEquals bar) } Output: true . | When Statement Using the when statement is like saying goodbye to the if and switch (well, Kotlin doesn’t have a switch statement anyway) statements: you’ll never want to go back again. Just look at this example in my FTC Angle data class and you’ll understand what I mean. val deg: Double get() = when(unit) { AngleUnit.RAD -&gt; angle.toDegrees AngleUnit.DEG -&gt; angle AngleUnit.RAW -&gt; angle } . Or when determining the metadata of a Waypoint: . val skip: Boolean = when(waypoint) { is StopWaypoint -&gt; .... is TurnWaypoint -&gt; .... is LateTurnWaypoint -&gt; .... else -&gt; .... } . See what I mean? . | Break labels Oftentimes I found myself annoyed with Java not having a specific break when inside nested statements/loops. Kotlin solves this annoyance with labels. Labels can annotate an expression, and breaks/returns can then jump straight to that label when that label is called. mainLoop@ for(i in 1..100) { for(j in 1..100) { if(...) break@mainLoop } } . Upon that nested if being fulfilled, the program will break out of both for loops. . | Java Interoperability Last but not least is Kotlin being fully compatible with Java. Any libraries written in Java can be used in Kotlin without any trouble, and any Kotlin classes can be used in Java with some extra annotations. Any Kotlin fields that are being used in a Java class must be labled with the @JVMField annotation, or with the @JVMStatic annotation if it’s a static field. | Thanks for reading, if you have any comments or concerns you can reach me at my email. .",
            "url": "https://asiankoala.github.io/my-blog/ftc/kotlin/2021/08/19/Kotlin-FTC-Tips.html",
            "relUrl": "/ftc/kotlin/2021/08/19/Kotlin-FTC-Tips.html",
            "date": " • Aug 19, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://asiankoala.github.io/my-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://asiankoala.github.io/my-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}