{
  
    
        "post0": {
            "title": "Dual Booting Arch Linux with a Windows 10 System",
            "content": "Pre Install . Downloading the ISO . Head over to the arch download page and download the ISO using either a magnet link if you have a torrent client, or directly from an appropriate mirror site . Once it’s been downloaded, burn the image onto a flash drive using rufus From the ArchWiki: . Note: If the USB drive does not boot properly using the default ISO Image mode, DD Image mode should be used instead. To switch this mode on, select GPT from the Partition scheme drop-down menu. After clicking START you will get the mode selection dialog, select DD Image mode. . Setting up Windows for Dualbooting . Creating the Linux partition . Search for “Disk Management” and hit enter. This should pop up. . Right-click on the partition of the disk that you wish to install Arch under. In cases with a single-disk system, this would simply be your (C:) partition under disk 0. Then click “Shrink Volume”, and allocate however much space you wish Arch to use. This can be changed later using GParted, so don’t fret too much about it’s initial size. If Windows is refusing to shrink your disk despite having enough free space, your best bet would be using GParted or another partition management software to handle the creation of your Linux partition. . Disabling Windows Settings . Before Arch is installed, several Windows settings must be disabled to allow the computer to safely and reliably boot into Arch. . UEFI Secure Boot . This is motherboard manufacturer-specific. Generally you will need to enter your BIOS, find a setting for “Secure Boot”, and disable it. . Fast Boot and Hibernation . Open the Control Panel and go to Power Options -&gt; Choose what the power buttons do -&gt; uncheck “Turn on fast startup (recommended)” . . Next is to disable hibernation. From the Microsoft Docs: . Press the Windows button on the keyboard to open Start menu or Start screen. | Search for cmd. In the search results list, right-click Command Prompt, and then select Run as Administrator. | When you are prompted by User Account Control, select Continue. | At the command prompt, type powercfg.exe /hibernate off, and then press Enter. Type exit, and then press Enter to close the Command Prompt window. | . Once all of that is finished, Arch can now be installed. . Installing Arch . Reboot your computer and enter the boot menu during startup. The key to enter varies depending on your motherboard manufacturer. For my MSI board, it was F11. . Select the flash drive that has the Arch image and select that to boot from. Then select the first option in the Arch install menu. . . Connect to the Internet . Enter iwctl with this: . # iwctl . Then find your WiFi device from the device list: . [iwd]# device list . In my case, it was wlan60 . And get the network name: . [iwd]# station DEVICE-NAME scan [iwd]# station DEVICE-NAME get-networks . Finally, connect to the desired network: . [iwd]# station DEVICE-NAME connect NETWORK-NAME . This will prompt you for the network password. . If you already know your device and network name, then simply enter this in the command line. . # iwctl --passphrase NETWORK-PASSWORD station DEVICE-NAME connect NETWORK-NAME . To verify your connection, use ping . # ping archlinux.org . Update Clock . # timedatectl set-ntp true . Partition Disks . Find the name of the disk you wish to install Arch under. . # fdisk -l or # lsblk . Then enter enter the partitioning program cfdisk . # cfdisk /dev/name_of_disk . In my case it was . # cfdisk /dev/nvme1n1 . . Hit the arrow keys to navigate to the table entry labeled “Free Space”. . First create the swap partition. There are various takes on how much swap size you should allow, but for system with 16GB ram 8GB should be perfectly fine. . Click enter on the “Free Space” entry and allocate 8GB by typing “8G”. Then move up to the newly created partition with the partition type “Linux filesystem”, and use the right arrow key to change the type of the partition. Then hit enter and select the “Linux Swap” option. . . Then scroll down to the “Free Space” entry again and allocate the rest to root partition. . Your screen should look like this. . . Before writing the changes to the disk, note down the root partition, swap partition, and “EFI System” partition names. . In the screenshot above, those would be /dev/sda5 and /dev/sda6 respectively. . In my case, they were /dev/nvme0n1np3 and /dev/nvme0n1p4. . You can view disk/partition information after this by using the fdisk -l or lsblk commands. . Double check that everything is correct. Now move over to the “Write” option and select it. . Mount Partitions . Now setup the partitions with the following commands. ROOT_PARTITION should be the name of your root partition. SWAP_PARTITION should be the name of your swap partition. EFI_PARTITION should be the name of your EFI partition. . # mkfs.ext4 /dev/ROOT_PARTITION # mkswap /dev/SWAP_PARTITION # swapon /dev/ROOT_PARTITION # mount /dev/ROOT_PARTITION /mnt # mount --mkdir /dev/EFI_PARTITION /mnt/efi . Install Linux and essential packages . # pacstrap /mnt base linux linux-firmware . Configure the system . # genfstab -U /mnt &gt;&gt; /mnt/etc/fstab # arch-chroot /mnt . Set the time zone . # ln -sf /usr/share/zoneinfo/REGION_HERE/CITY_HERE /etc/localtime # hwclock --systohc . In my case (US Eastern) the command looks like this: . # ln -sf /usr/share/zoneinfo/US/Eastern /etc/localtime . While typing out a directory, you can press Tab to explore/autocomplete, which is useful in seeing different timezone options. . Install an editor . # pacman -Sy vim If you’re familiar with vim, or # pacman -Sy nano For a simpler text editor. . Set Locale . Edit /etc/locale.gen and uncomment en_US.UTF-8 UTF-8. . Then generate the locales with: . # locale-gen . Create the locale.conf file in /etc/ . # vim /etc/locale.conf . And add this single line: . LANG=en_US.UTF-8 . . Hostname . Create the hostname file and edit it to set the name of your machine on the network. . # vim /etc/hostname . My hostname file looks like this: . . Now edit the /etc/hosts file to look like this: . . Replace “koawa” with your hostname that you just set. Make sure to tab once in between the ip’s and hostnames. . User . Add a user to the system with this: . # useradd -G wheel,audio,video -m USERNAME . Set that user’s password with: . # passwd USERNAME . And set the root password with: . # passwd . Grub . pacman -S grub efibootmgr os-prober grub-install --target=x86_64-efi --efi-directory=/efi/ --bootloader-id=GRUB . Edit the /etc/default/grub file and add/uncomment . GRUB_DISABLE_OS_PROBER=false . Now enter: . # grub-mkconfig -o /boot/grub/grub.cfg . Network Setup . This is how I set up my wireless network using NetworkManager. For a wired connection, check the ArchWiki Ethernet Page . If you wish to use another wireless network configuration, again, check the ArchWiki Wireless Page . Install NetworkManager and reboot your system. . # pacman -S networkmanager # exit # reboot . You should see the GRUB menu on boot. If you don’t, then reorder the boot priority of your system through the BIOS. Now press enter on “Arch Linux” (or just wait, as it will automatically boot into Arch after some time). . Now enter these commands to setup your network. . $ nmcli d $ nmcli r wifi on $ nmcli d wifi list $ nmcli d wifi connect WIFI_SSID_HERE password --YOUR_PASSWORD_HERE . And now Arch has been fully installed with networking capabilities. . To learn about how to make your Arch look similar to mine, shown below, head over to my dotfiles or read some of my other Arch Linux blog posts. . .",
            "url": "https://asiankoala.github.io/my-blog/linux/2022/05/22/Dualbooting-Arch-Linux.html",
            "relUrl": "/linux/2022/05/22/Dualbooting-Arch-Linux.html",
            "date": " • May 22, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Custom Keyboards",
            "content": "Introduction . I’ve been a keyboard enthusiast for several years now. Back when I built my first computer, I bought the Corsair K70RGB, a standard, run-of-the-mill keyboard. This first computer build ignited by interest in PC peripherals, later leading me to my first keyboard customization: keycaps. The physical keys that you type on are called keycaps, and are a popular modification. I purchased pudding keycaps, a special type of keycap that allows RGB light to shine through the side “walls”. . &lt;img src=./images/k70.jpg&gt;&lt;/img&gt; Corsair K70 RGB &lt;img src=./images/pudding.jpg&gt;&lt;/img&gt; Pudding keycaps . A bit deeper . Around a year after the purchase of those pudding keycaps on my K70, I grew to be annoyed by the size of the keyboard. During gaming, my right hand would frequently make contact with the numpad of the K70, and during study sessions there wouldn’t be enough room to lay out all my papers. Also, tilting my keyboard in order to provide a more comfortable resting position proved to be a challenge due to how small my old desk was. To solve this, I did a bit of research and discovered the Ducky One 2 Mini, a smaller keyboard containing only 60% of the standard 108 keys (only alphanumeric and modifiers), hence the given name for this form factor by the keyboard community as a “60% keyboard”. . &lt;img src=./images/ducky.png&gt;&lt;/img&gt; Ducky One 2 Mini I found the Ducky One 2 Mini to be an excellent purchase, and miles ahead of the Corsair K70 I owned. The many subtle improvements on the Ducky One 2 Mini added up to create an amazing experience that the K70 couldn’t achieve. For example, the spacebar on my K70 would frequently rattle as the stabilizers used were poor quality. Overall a great purchase and definitely would recommend. . Similarly to with the K70, I also bought keycaps several months after purchasing my Ducky One 2 Mini. The first set was the Ducky Joker PBT Double-Shot keycap set. In contrast to standard ABS plastic used in my old keyboard, these keycaps use PBT, a harder, thicker plastic that is much harder to shine. In addition, I also bought rubber keycaps from Tai-Hao which provided a better grip on the keys normally used for playing video games. . &lt;img src=./images/joker.jpg&gt;&lt;/img&gt; Joker keycaps &lt;img src=./images/taihao.webp&gt;&lt;/img&gt; Tai-Hao rubber keycaps Entering the Keyboard Community . This satisfied me for a while, but as all keyboard enthusiasts do, I eventually came upon the interesting subreddit r/MechanicalKeyboards. Many people have differing opinions on the quality of this subreddit, but regardless, to me it served as a gateway into the hobby of keyboards. Looking back on it, there is a lot of poor advice given on that subreddit, and I wouldn’t necessarily recommend it to people starting out in the hobby. As is always with reddit, there is an overflow of nastiness inherently springing from anonymity. . Anyway, I first learned about keyboards here. A multitude of guides, posts, tutorials and more are available on the subreddit that contain essential information to the keyboard hobby. I learned about the different types of switches (linears, tactiles, dome, alps, etc.), lubes for different levels of fluidity, (tribosys 3203,3204, krytox 105, 205g0), keycap profiles, PCBs, plates, dampening foam/stickers, custom cases, hotswap, soldering, and so much more. . This accumulated in me buying parts to build my first custom mechanical keyboard which I built in the summer before my freshman year at TJHSST. I’ll be blogging about this in a later post. . Most recently, I acquired Graystudio’s Space80:Apollo, an absolutely stunning keyboard. My experience with it has been nothing short of stellar, and I’ll blog about this as well in the coming week after my tests are done. In the mean time, although low quality, here’s a picture of the final build. . &lt;img src=./images/space80.jpg&gt;&lt;/img&gt; My current keyboard - The Space80: Apollo by Graystudio",
            "url": "https://asiankoala.github.io/my-blog/keyboards/computers/2022/03/04/Keyboards.html",
            "relUrl": "/keyboards/computers/2022/03/04/Keyboards.html",
            "date": " • Mar 4, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Finite State Machines",
            "content": "A common problem new programmers face in robotics is running a several complex seriesof actions asynchrounously. Finite state machines (FSMs) are often used to solvethis. FSMs are literally as they sound: machines that have states. At any time, the FSM runs a single state. On completion of this state, this FSM will iterate to the next state. This repeats until the last state in the FSM has been completed. . Defining our expectations . In each stage of the program, the FSM needs to know the current state and actionto run. Furthermore, the FSM should know when to transition to the next stage, as well as running an action during these transitions. To reiterate: . Transition to stage N | Stage N-1 exit action runs | Stage N enter action runs | Stage N loop action runs | Check if stage N should transition | If true, run stage N exit action, transition, and run stage N+1 enter action | Implementation wise, we want to instantiate a FSM without too much effort. The easiest way to construct a dynamic object is with the builder pattern. . | Having several actions would be nice as well, so actions for each stage should be held in lists. . | To be as flexible as possible, the FSM should have the ability to stop or reset at any time. . | Transitions should easily implement a timer based system for timed transitions . | . Implementation (Kotlin) . To implement these requirements, we will follow my state machine library writtenin Kotlin. I took inspiration for the library from @NoahBres’s Jotai library. . First, lets implement an “action”. An action should be a single function that simply runs. In Kotlin, the easiest method of writing such a requirement is to usea Functional SAM (Single Abstract Method) Interface. . fun interface Action { fun run() } . We can now pass this action interface into functions to invoke the run() method, similar to how a lambda functions. Functional interfaces in kotlin have special syntax . fun runAction(myAction: Action) { myAction.run() } runAction { println(&quot;Hello World!&quot; } . Now let us define a similar functional interface for transitioning between states. The state machine will repeatedly check the transition condition to see if the current state is finished, meaning we need a method returning a boolean. . fun interface Transition { fun shouldTransition(): Boolean } . Similarly to Action, Transition can also use functional interface syntax. . fun printShouldTransition(t: Transition) { print(t.shouldTransition()) } val t = { true } printShouldTransition(t) . returns true . Now we have enough to define a “State”. Referring back to our definitions of a state, we need to have lists of actions for each stage of the state, as well as atransition condition. Each state should have an Enum associated with it, as thiswill simplify writing code. Data classes in Kotlin serve this need well, as theypregenerate some useful functions. Specific actions should be ran when entering the state, when looping before transitioning, and then on transition. . data class State&lt;T&gt; { var state: T, var onEnter: MutableList&lt;Action&gt;, var onLoop: MutableList&lt;Action&gt;, var onExit: MutableList&lt;Action&gt;, var transition: TransitionCondition = { true } | . Notice I defaulted the transition variable to a value of true. This is personal preference, as if I have a state with no transition condition I want the state machine to assume the state is finished. If you don’t want this feature, requiring that a state has a transition condition when building the state machine is an easy addition that I will elaborate on later. . Now that we have classes for Actions, Transitions, and States, all that is left is to write the main StateMachine logic and the StateMachineBuilder class utilizng the builder pattern for ease of use. . I will skim over some details of my StateMachine class with psuedocode, as the main class is fairly trivial. If you wish to read my StateMachine code, it is available here. . The header of the StateMachine class is standard. Each state machine has a generic associated with it, which will be supplied on creation of a StateMachine object as an enum, and a list of states. . class StateMachine&lt;T&gt;(private val stateList: List&lt;State&lt;T&gt;&gt;) { ... } . Having the state machine running at all times would be harmful so a running variable would be useful, as well as a currentState variable to save the current state we are running in stateList. Current state can be either an indice value (so, an integer) or a “T”, but that is up to the reader to decide. There’s no real benefit besides whatever is easier to you. . Next, lets define what the state machine does when it starts. On start, the running variable should be set to true, and all enter actions of the current state should run. Note that current state does not necessarily denote the first state to run; a state machine can be stopped and started at any phase while traversing the stateList. . fun start() { running = true currentAction.enterActions(Action::run) } . Our next function, update() is also fairly straightforward. Update is called periodicly while the state machine is running. It first checks if the currentState’s transition condition is true, and if so, transitions. If the state machine has stopped running (running == false), it returns and stops the update() function. After these 2 checks, it runs all the loopActions of the currentState. I’ll leave the implementation up to the reader for this one. . The last function of the StateMachine class is our transition() function. This is called when the currentState’s transition condition is true in the update() method. The function first runs all the exitActions of the currentState, and then sets currentState = to the next state in stateList. As I implemented currentState to be , I used stateList.indexOf(currentState) to find the current state in the stateList, but currentState as an index would simply be currentState++. Then, we run all the enterActions of the newState, which is our currentState. . And that’s it! You can now use your StateMachine class to program complicated movements on your robots that might’ve otherwise taken hours of frustration in a much shorter timeframe. I’ll soon write a post on how to implement the builder method to quickly create a stateList effortlessly. In the meanwhile, I’ll add a small code snippet displaying how the builder pattern works in my state machine implementation. Good luck! . val IntakeEnum { ON, CHECKING_FOR_MINERAL, OFF } val intakeStateMachine = StateMachineBuilder&lt;IntakeEnum&gt;() .state(ON) .onEnter(intake::turnOn) .transition { true } .state(CHECKING_FOR_MINERAL) .transition(sensor::isMineralIn) .state(OFF) .onEnter(intake::turnOff) .transition { true } .build() .",
            "url": "https://asiankoala.github.io/my-blog/robotics/kotlin/2021/10/25/Finite-State-Machine.html",
            "relUrl": "/robotics/kotlin/2021/10/25/Finite-State-Machine.html",
            "date": " • Oct 25, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "FTC Kotlin Tips & Tricks",
            "content": "Kotlin is a statically typed, modern, concise JVM language that is designed to be fully interoperable with Java. In FTC, the most popular motion planning library, &lt;a href=https://learnroadrunner.com/&gt;Road Runner,&lt;/a&gt; is written in Kotlin. . Enabling Kotlin . First, we have to enable the Kotlin plugin in our root level gradle files. Navigate to ./build.gradle and add this line to your buildscript . ext.kotlin_version = &#39;1.5.21&#39; . Note: - at the time of writing 1.5.21 is the latest Kotlin release. . This creates an environment variable with name ‘kotlin_version’ and value ‘1.5.21’ so we don’t have to re-type the release version. . Next, add the Kotlin plugin to the dependencies block with this line classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; . If you haven’t already, make sure the language level of the Java source code and version of the generated Java bytecode are 1.8 (JDK 8). Open up build.common.gradle and check if your compileOptions block looks like this . compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } . Once that’s finished, all that’s left to do is to enable the kotlin-android and the kotlin-stdlib-jdk8 plugins. Head over to the build.gradle of any modules you want to use Kotlin in. . Personally, I have Kotlin enabled in both the TeamCode and FTCRobotController modules as I converted the Java sample code that the FTC SDK provides to Kotlin to introduce my jr programmer to the SDK and Kotlin at the same time. Add the following definition to the top of your build.gradle file. apply plugin: &#39;kotlin-android&#39; . Then add this line to your dependencies block. implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version&quot; . Sync your gradle changes and then you’re all good. . . Converting your codebase to Kotlin . If you’re apprehensive about the how long it’ll take to rewrite everything, don’t worry. As Kotlin was designed to be fully functional with Java, Java source code can actually be converted directly into readable Kotlin code. Head over to Android Studio and press ctrl+alt+shift+K while a Java file is open to convert it to Kotlin. . Now that you have Kotlin files to work with, let me give some basic functionalities that I wish I knew back when I started developing in Kotlin. . Tips &amp; Tricks . Data Classes . Whenever you have classes that are only for holding data, such as a Vector or Point class, turn them into a data class. Data classes contain automatically generated functions that are derived from the constructor fields, which makes life simpler. You can also do cool things with data classes like this: val (x, y) = Point(1.0, 2.0) . | Custom getters/setters . I remember during one of my first days after switching to Kotlin, I spent an entire meeting trying to debug a StackOverflowError that made no sense at all. It was erroring at a ‘simple’ variable that should never have errored, right? Or so I thought. The error was pointing to this simple line: val dbNormalize = Point(-y, x) At first glance it looks like a completely valid piece of code, but the field was actually declared in the Point data class. The Java equivalent of this would be perfectly valid, but for this you need to specify a custom getter like this: val dbNormalize get() = Point(-y, x) The full form of any Kotlin field is as follows: . val foo:type = type(a, b, c...) get() = field set(value) { field = value } . | Extension Functions . Extension functions were the thing that really made me feel good about switching to Kotlin. The amount of flexibility it offers is amazing. They provide you to define custom functions for any class but “extending” it. This also applies to fields/properties. For example, look at the following example. In FTC angle math is used a lot, and we always want to make sure that the angles we use are between some specified bounds, usually between -π and π. . fun Double.wrap(): Double { angle = this while(angle &gt;= PI) angle -= PI * 2 while(angle &lt; -PI) angle += PI * 2 return angle } val Double.toRadians: Double = Math.toRadians(this) val Double.toDegrees: Double = Math.toDegrees(this) . Now I can call this method on any double, like this. . val myAngleDegrees = 180.0 val myAngleRad = myAngleDegrees.toRadians println(myAngleRad.wrap().toDegrees) Output: -180.0 . | Null Safety . Kotlin is supposed to be safe, so what does it do with the dreaded null-types? Simple, nothing can be null unless specifically stated, and even if it is null, there are compile-time checks to make sure nothing goes haywire. To declare a variable as possibly null, you add the ? to the end of the type declaration, like this. var foo: String? = &quot;abc&quot; But what happens if it is null? At compile time if you ever access foo without checking if it’s null, Kotlin will throw a “can possibly be null” error. The correct way to access foo would be like this. val length = foo?.length ?: -1 This is equivalent to the following, more verbose expression. val l: Int = if(foo != null) foo.length else -1 And if you really do love having Null Pointer Exceptions, you can assert that a field is not null with !!. Ex: val l = b!!.length . | kotlin.math . This is a short one, but the built in extension functions in the kotlin.math class feel really good to use, such as the Double.sign extension field or the Double.exp function. . | Operator Overloading . Operator overloading is a must know for anyone who frequently uses any sort of data class such as the aforementioned Vector or Point data classes. Basic unary/binary operators such as the increment operator or the adding operator can be overloaded with your custom definition. Let me just show how much cleaner it is. . data class Point(var x: Int, var y: Int) { operator fun plus(p: Point) = Point(x + p.x, y + p.y) operator fun times(n: Double) = Point(x * n, y * n) operator fun unaryMinus(p: Point) = this.times(-1.0) override fun toString() = x + &quot;, &quot; + y } fun main() { val foo = Point(2,3) val bar = Point(3,2) val foobar = foo + bar println(foobar.toString()) val minusfoobar = -foobar println(minusfoo.toString() } Output: 5, 5 -5, -5 . | Infix Functions . Can’t talk about operator overloading without mentioning infix functions. Infix functions are functions that can be called without the dot. I’m not that much of a fan of this due to the possible danger of making stuff so simple that it gets way too overcomplicated, but it does have its uses. Sometimes when I want to approximate something equal to another, I would previously have to do this: Math.abs(a-b) &lt; 1e6 , but with infix notation it becomes a lot cleaner. . infix fun Double.epsilonEquals(a: Double): Boolean { return if(this.isInfinite()) this == a else (this - a).absoluteValue &lt; EPSILON } fun main() { val foo = 1.0 val bar = foo * 1.00000000000001 println(foo epsilonEquals bar) } Output: true . | When Statement . Using the when statement is like saying goodbye to the if and switch (well, Kotlin doesn’t have a switch statement anyway) statements: you’ll never want to go back again. Just look at this example in my FTC Angle data class and you’ll understand what I mean. . val deg: Double get() = when(unit) { AngleUnit.RAD -&gt; angle.toDegrees AngleUnit.DEG -&gt; angle AngleUnit.RAW -&gt; angle } . Or when determining the metadata of a Waypoint: . val skip: Boolean = when(waypoint) { is StopWaypoint -&gt; .... is TurnWaypoint -&gt; .... is LateTurnWaypoint -&gt; .... else -&gt; .... } . See what I mean? . | Break labels . Oftentimes I found myself annoyed with Java not having a specific break when inside nested statements/loops. Kotlin solves this annoyance with labels. Labels can annotate an expression, and breaks/returns can then jump straight to that label when that label is called. . mainLoop@ for(i in 1..100) { for(j in 1..100) { if(...) break@mainLoop } } . Upon that nested if being fulfilled, the program will break out of both for loops. . | Java Interoperability . Last but not least is Kotlin being fully compatible with Java. Any libraries written in Java can be used in Kotlin without any trouble, and any Kotlin classes can be used in Java with some extra annotations. Any Kotlin fields that are being used in a Java class must be labled with the @JVMField annotation, or with the @JVMStatic annotation if it’s a static field. . | Thanks for reading, if you have any comments or concerns you can reach me at my email. .",
            "url": "https://asiankoala.github.io/my-blog/ftc/kotlin/robotics/2021/08/19/Kotlin-FTC-Tips.html",
            "relUrl": "/ftc/kotlin/robotics/2021/08/19/Kotlin-FTC-Tips.html",
            "date": " • Aug 19, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hello, I’m a junior at TJHSST interested in CS, SWE, competitive programming, robotics, and control theory. . In my free time I like to study Japanese, read manga, and listen to music. I used to be a huge anime fan but sadly school has left me with barely any time for it. Nevertheless you can find my MyAnimeList account here. . On the side, I love listening to Japanese 80s City Pop, Jazz Fusion, and Future Funk. Here’s my spotify playlist if interested. My favorite artists are Junko Yagami, Momoko Kikuchi, Bread and Butter, Yuri Tanaka, and Wink! . I also like to create YouTube videos for fun, centering on robotics or a project im working on. Here is my youtube channel .",
          "url": "https://asiankoala.github.io/my-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://asiankoala.github.io/my-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}